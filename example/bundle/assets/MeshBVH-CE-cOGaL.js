import{B as _n,V as z,q as nt,bn as Pt,aR as ft,p as un,bo as zn,b as j,U as xt,J as Mt,aQ as Rn,y as Dn,t as Fn,x as pn}from"./ExtendedTriangle-CFC-kWKu.js";const Pn=0,Nn=1,vn=2,vi=0,Vi=1,yn=2,Ht=1.25,xn=1,bt=6*4+4+4,qt=65535,Vn=Math.pow(2,-24),jt=Symbol("SKIP_GENERATION");function $n(i){return i.index?i.index.count:i.attributes.position.count}function ut(i){return $n(i)/3}function In(i,n=ArrayBuffer){return i>65535?new Uint32Array(new n(4*i)):new Uint16Array(new n(2*i))}function kn(i,n){if(!i.index){const t=i.attributes.position.count,e=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=In(t,e);i.setIndex(new _n(s,1));for(let c=0;c<t;c++)s[c]=c}}function Mn(i,n){const t=ut(i),e=n||i.drawRange,s=e.start/3,c=(e.start+e.count)/3,r=Math.max(0,s),l=Math.min(t,c)-r;return[{offset:Math.floor(r),count:Math.floor(l)}]}function Sn(i,n){if(!i.groups||!i.groups.length)return Mn(i,n);const t=[],e=new Set,s=n||i.drawRange,c=s.start/3,r=(s.start+s.count)/3;for(const o of i.groups){const u=o.start/3,f=(o.start+o.count)/3;e.add(Math.max(c,u)),e.add(Math.min(r,f))}const l=Array.from(e.values()).sort((o,u)=>o-u);for(let o=0;o<l.length-1;o++){const u=l[o],f=l[o+1];t.push({offset:Math.floor(u),count:Math.floor(f-u)})}return t}function qn(i,n){const t=ut(i),e=Sn(i,n).sort((r,l)=>r.offset-l.offset),s=e[e.length-1];s.count=Math.min(t-s.offset,s.count);let c=0;return e.forEach(({count:r})=>c+=r),t!==c}function Yt(i,n,t,e,s){let c=1/0,r=1/0,l=1/0,o=-1/0,u=-1/0,f=-1/0,y=1/0,a=1/0,p=1/0,d=-1/0,b=-1/0,g=-1/0;for(let h=n*6,x=(n+t)*6;h<x;h+=6){const m=i[h+0],w=i[h+1],A=m-w,T=m+w;A<c&&(c=A),T>o&&(o=T),m<y&&(y=m),m>d&&(d=m);const B=i[h+2],P=i[h+3],S=B-P,M=B+P;S<r&&(r=S),M>u&&(u=M),B<a&&(a=B),B>b&&(b=B);const U=i[h+4],_=i[h+5],C=U-_,L=U+_;C<l&&(l=C),L>f&&(f=L),U<p&&(p=U),U>g&&(g=U)}e[0]=c,e[1]=r,e[2]=l,e[3]=o,e[4]=u,e[5]=f,s[0]=y,s[1]=a,s[2]=p,s[3]=d,s[4]=b,s[5]=g}function Xn(i,n=null,t=null,e=null){const s=i.attributes.position,c=i.index?i.index.array:null,r=ut(i),l=s.normalized;let o;n===null?(o=new Float32Array(r*6),t=0,e=r):(o=n,t=t||0,e=e||r);const u=s.array,f=s.offset||0;let y=3;s.isInterleavedBufferAttribute&&(y=s.data.stride);const a=["getX","getY","getZ"];for(let p=t;p<t+e;p++){const d=p*3,b=p*6;let g=d+0,h=d+1,x=d+2;c&&(g=c[g],h=c[h],x=c[x]),l||(g=g*y+f,h=h*y+f,x=x*y+f);for(let m=0;m<3;m++){let w,A,T;l?(w=s[a[m]](g),A=s[a[m]](h),T=s[a[m]](x)):(w=u[g+m],A=u[h+m],T=u[x+m]);let B=w;A<B&&(B=A),T<B&&(B=T);let P=w;A>P&&(P=A),T>P&&(P=T);const S=(P-B)/2,M=m*2;o[b+M+0]=B+S,o[b+M+1]=S+(Math.abs(B)+S)*Vn}}return o}function D(i,n,t){return t.min.x=n[i],t.min.y=n[i+1],t.min.z=n[i+2],t.max.x=n[i+3],t.max.y=n[i+4],t.max.z=n[i+5],t}function An(i){let n=-1,t=-1/0;for(let e=0;e<3;e++){const s=i[e+3]-i[e];s>t&&(t=s,n=e)}return n}function mn(i,n){n.set(i)}function hn(i,n,t){let e,s;for(let c=0;c<3;c++){const r=c+3;e=i[c],s=n[c],t[c]=e<s?e:s,e=i[r],s=n[r],t[r]=e>s?e:s}}function St(i,n,t){for(let e=0;e<3;e++){const s=n[i+2*e],c=n[i+2*e+1],r=s-c,l=s+c;r<t[e]&&(t[e]=r),l>t[e+3]&&(t[e+3]=l)}}function At(i){const n=i[3]-i[0],t=i[4]-i[1],e=i[5]-i[2];return 2*(n*t+t*e+e*n)}const Y=32,Hn=(i,n)=>i.candidate-n.candidate,K=new Array(Y).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Ct=new Float32Array(6);function jn(i,n,t,e,s,c){let r=-1,l=0;if(c===Pn)r=An(n),r!==-1&&(l=(n[r]+n[r+3])/2);else if(c===Nn)r=An(i),r!==-1&&(l=Yn(t,e,s,r));else if(c===vn){const o=At(i);let u=Ht*s;const f=e*6,y=(e+s)*6;for(let a=0;a<3;a++){const p=n[a],g=(n[a+3]-p)/Y;if(s<Y/4){const h=[...K];h.length=s;let x=0;for(let w=f;w<y;w+=6,x++){const A=h[x];A.candidate=t[w+2*a],A.count=0;const{bounds:T,leftCacheBounds:B,rightCacheBounds:P}=A;for(let S=0;S<3;S++)P[S]=1/0,P[S+3]=-1/0,B[S]=1/0,B[S+3]=-1/0,T[S]=1/0,T[S+3]=-1/0;St(w,t,T)}h.sort(Hn);let m=s;for(let w=0;w<m;w++){const A=h[w];for(;w+1<m&&h[w+1].candidate===A.candidate;)h.splice(w+1,1),m--}for(let w=f;w<y;w+=6){const A=t[w+2*a];for(let T=0;T<m;T++){const B=h[T];A>=B.candidate?St(w,t,B.rightCacheBounds):(St(w,t,B.leftCacheBounds),B.count++)}}for(let w=0;w<m;w++){const A=h[w],T=A.count,B=s-A.count,P=A.leftCacheBounds,S=A.rightCacheBounds;let M=0;T!==0&&(M=At(P)/o);let U=0;B!==0&&(U=At(S)/o);const _=xn+Ht*(M*T+U*B);_<u&&(r=a,u=_,l=A.candidate)}}else{for(let m=0;m<Y;m++){const w=K[m];w.count=0,w.candidate=p+g+m*g;const A=w.bounds;for(let T=0;T<3;T++)A[T]=1/0,A[T+3]=-1/0}for(let m=f;m<y;m+=6){let T=~~((t[m+2*a]-p)/g);T>=Y&&(T=Y-1);const B=K[T];B.count++,St(m,t,B.bounds)}const h=K[Y-1];mn(h.bounds,h.rightCacheBounds);for(let m=Y-2;m>=0;m--){const w=K[m],A=K[m+1];hn(w.bounds,A.rightCacheBounds,w.rightCacheBounds)}let x=0;for(let m=0;m<Y-1;m++){const w=K[m],A=w.count,T=w.bounds,P=K[m+1].rightCacheBounds;A!==0&&(x===0?mn(T,Ct):hn(T,Ct,Ct)),x+=A;let S=0,M=0;x!==0&&(S=At(Ct)/o);const U=s-x;U!==0&&(M=At(P)/o);const _=xn+Ht*(S*x+M*U);_<u&&(r=a,u=_,l=w.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${c} used.`);return{axis:r,pos:l}}function Yn(i,n,t,e){let s=0;for(let c=n,r=n+t;c<r;c++)s+=i[c*6+e*2];return s/t}class Zt{constructor(){this.boundingData=new Float32Array(6)}}function Zn(i,n,t,e,s,c){let r=e,l=e+s-1;const o=c.pos,u=c.axis*2;for(;;){for(;r<=l&&t[r*6+u]<o;)r++;for(;r<=l&&t[l*6+u]>=o;)l--;if(r<l){for(let f=0;f<3;f++){let y=n[r*3+f];n[r*3+f]=n[l*3+f],n[l*3+f]=y}for(let f=0;f<6;f++){let y=t[r*6+f];t[r*6+f]=t[l*6+f],t[l*6+f]=y}r++,l--}else return r}}function Kn(i,n,t,e,s,c){let r=e,l=e+s-1;const o=c.pos,u=c.axis*2;for(;;){for(;r<=l&&t[r*6+u]<o;)r++;for(;r<=l&&t[l*6+u]>=o;)l--;if(r<l){let f=i[r];i[r]=i[l],i[l]=f;for(let y=0;y<6;y++){let a=t[r*6+y];t[r*6+y]=t[l*6+y],t[l*6+y]=a}r++,l--}else return r}}function V(i,n){return n[i+15]===65535}function $(i,n){return n[i+6]}function I(i,n){return n[i+14]}function k(i){return i+8}function q(i,n){return n[i+6]}function Cn(i,n){return n[i+7]}function $i(i){return i}let Un,Tt,It,Ln;const Jn=Math.pow(2,32);function tn(i){return"count"in i?1:1+tn(i.left)+tn(i.right)}function Qn(i,n,t){return Un=new Float32Array(t),Tt=new Uint32Array(t),It=new Uint16Array(t),Ln=new Uint8Array(t),nn(i,n)}function nn(i,n){const t=i/4,e=i/2,s="count"in n,c=n.boundingData;for(let r=0;r<6;r++)Un[t+r]=c[r];if(s)if(n.buffer){const r=n.buffer;Ln.set(new Uint8Array(r),i);for(let l=i,o=i+r.byteLength;l<o;l+=bt){const u=l/2;V(u,It)||(Tt[l/4+6]+=t)}return i+r.byteLength}else{const r=n.offset,l=n.count;return Tt[t+6]=r,It[e+14]=l,It[e+15]=qt,i+bt}else{const r=n.left,l=n.right,o=n.splitAxis;let u;if(u=nn(i+bt,r),u/4>Jn)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return Tt[t+6]=u/4,u=nn(u,l),Tt[t+7]=o,u}}function Wn(i,n){const t=(i.index?i.index.count:i.attributes.position.count)/3,e=t>2**16,s=e?4:2,c=n?new SharedArrayBuffer(t*s):new ArrayBuffer(t*s),r=e?new Uint32Array(c):new Uint16Array(c);for(let l=0,o=r.length;l<o;l++)r[l]=l;return r}function Gn(i,n,t,e,s){const{maxDepth:c,verbose:r,maxLeafTris:l,strategy:o,onProgress:u,indirect:f}=s,y=i._indirectBuffer,a=i.geometry,p=a.index?a.index.array:null,d=f?Kn:Zn,b=ut(a),g=new Float32Array(6);let h=!1;const x=new Zt;return Yt(n,t,e,x.boundingData,g),w(x,t,e,g),x;function m(A){u&&u(A/b)}function w(A,T,B,P=null,S=0){if(!h&&S>=c&&(h=!0,r&&(console.warn(`MeshBVH: Max depth of ${c} reached when generating BVH. Consider increasing maxDepth.`),console.warn(a))),B<=l||S>=c)return m(T+B),A.offset=T,A.count=B,A;const M=jn(A.boundingData,P,n,T,B,o);if(M.axis===-1)return m(T+B),A.offset=T,A.count=B,A;const U=d(y,p,n,T,B,M);if(U===T||U===T+B)m(T+B),A.offset=T,A.count=B;else{A.splitAxis=M.axis;const _=new Zt,C=T,L=U-T;A.left=_,Yt(n,C,L,_.boundingData,g),w(_,C,L,g,S+1);const E=new Zt,F=U,Z=B-L;A.right=E,Yt(n,F,Z,E.boundingData,g),w(E,F,Z,g,S+1)}return A}}function On(i,n){const t=i.geometry;n.indirect&&(i._indirectBuffer=Wn(t,n.useSharedArrayBuffer),qn(t,n.range)&&!n.verbose&&console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),i._indirectBuffer||kn(t,n);const e=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=Xn(t),c=n.indirect?Mn(t,n.range):Sn(t,n.range);i._roots=c.map(r=>{const l=Gn(i,s,r.offset,r.count,n),o=tn(l),u=new e(bt*o);return Qn(0,l,u),u})}class v{constructor(n,t,e){this.isOrientedBox=!0,this.min=new z,this.max=new z,this.matrix=new nt,this.invMatrix=new nt,this.points=new Array(8).fill().map(()=>new z),this.satAxes=new Array(3).fill().map(()=>new z),this.satBounds=new Array(3).fill().map(()=>new Pt),this.alignedSatBounds=new Array(3).fill().map(()=>new Pt),this.needsUpdate=!1,n&&this.min.copy(n),t&&this.max.copy(t),e&&this.matrix.copy(e)}set(n,t,e){this.min.copy(n),this.max.copy(t),this.matrix.copy(e),this.needsUpdate=!0}copy(n){this.min.copy(n.min),this.max.copy(n.max),this.matrix.copy(n.matrix),this.needsUpdate=!0}}v.prototype.update=function(){return function(){const n=this.matrix,t=this.min,e=this.max,s=this.points;for(let u=0;u<=1;u++)for(let f=0;f<=1;f++)for(let y=0;y<=1;y++){const a=1*u|2*f|4*y,p=s[a];p.x=u?e.x:t.x,p.y=f?e.y:t.y,p.z=y?e.z:t.z,p.applyMatrix4(n)}const c=this.satBounds,r=this.satAxes,l=s[0];for(let u=0;u<3;u++){const f=r[u],y=c[u],a=1<<u,p=s[a];f.subVectors(l,p),y.setFromPoints(f,s)}const o=this.alignedSatBounds;o[0].setFromPointsField(s,"x"),o[1].setFromPointsField(s,"y"),o[2].setFromPointsField(s,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();v.prototype.intersectsBox=function(){const i=new Pt;return function(t){this.needsUpdate&&this.update();const e=t.min,s=t.max,c=this.satBounds,r=this.satAxes,l=this.alignedSatBounds;if(i.min=e.x,i.max=s.x,l[0].isSeparated(i)||(i.min=e.y,i.max=s.y,l[1].isSeparated(i))||(i.min=e.z,i.max=s.z,l[2].isSeparated(i)))return!1;for(let o=0;o<3;o++){const u=r[o],f=c[o];if(i.setFromBox(u,t),f.isSeparated(i))return!1}return!0}}();v.prototype.intersectsTriangle=function(){const i=new ft,n=new Array(3),t=new Pt,e=new Pt,s=new z;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(i.copy(r),i.update(),r=i);const l=this.satBounds,o=this.satAxes;n[0]=r.a,n[1]=r.b,n[2]=r.c;for(let a=0;a<3;a++){const p=l[a],d=o[a];if(t.setFromPoints(d,n),p.isSeparated(t))return!1}const u=r.satBounds,f=r.satAxes,y=this.points;for(let a=0;a<3;a++){const p=u[a],d=f[a];if(t.setFromPoints(d,y),p.isSeparated(t))return!1}for(let a=0;a<3;a++){const p=o[a];for(let d=0;d<4;d++){const b=f[d];if(s.crossVectors(p,b),t.setFromPoints(s,n),e.setFromPoints(s,y),t.isSeparated(e))return!1}}return!0}}();v.prototype.closestPointToPoint=function(){return function(n,t){return this.needsUpdate&&this.update(),t.copy(n).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t}}();v.prototype.distanceToPoint=function(){const i=new z;return function(t){return this.closestPointToPoint(t,i),t.distanceTo(i)}}();v.prototype.distanceToBox=function(){const i=["x","y","z"],n=new Array(12).fill().map(()=>new un),t=new Array(12).fill().map(()=>new un),e=new z,s=new z;return function(r,l=0,o=null,u=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(o||u)&&(r.getCenter(s),this.closestPointToPoint(s,e),r.closestPointToPoint(e,s),o&&o.copy(e),u&&u.copy(s)),0;const f=l*l,y=r.min,a=r.max,p=this.points;let d=1/0;for(let g=0;g<8;g++){const h=p[g];s.copy(h).clamp(y,a);const x=h.distanceToSquared(s);if(x<d&&(d=x,o&&o.copy(h),u&&u.copy(s),x<f))return Math.sqrt(x)}let b=0;for(let g=0;g<3;g++)for(let h=0;h<=1;h++)for(let x=0;x<=1;x++){const m=(g+1)%3,w=(g+2)%3,A=h<<m|x<<w,T=1<<g|h<<m|x<<w,B=p[A],P=p[T];n[b].set(B,P);const M=i[g],U=i[m],_=i[w],C=t[b],L=C.start,E=C.end;L[M]=y[M],L[U]=h?y[U]:a[U],L[_]=x?y[_]:a[U],E[M]=a[M],E[U]=h?y[U]:a[U],E[_]=x?y[_]:a[U],b++}for(let g=0;g<=1;g++)for(let h=0;h<=1;h++)for(let x=0;x<=1;x++){s.x=g?a.x:y.x,s.y=h?a.y:y.y,s.z=x?a.z:y.z,this.closestPointToPoint(s,e);const m=s.distanceToSquared(e);if(m<d&&(d=m,o&&o.copy(e),u&&u.copy(s),m<f))return Math.sqrt(m)}for(let g=0;g<12;g++){const h=n[g];for(let x=0;x<12;x++){const m=t[x];zn(h,m,e,s);const w=e.distanceToSquared(s);if(w<d&&(d=w,o&&o.copy(e),u&&u.copy(s),w<f))return Math.sqrt(w)}}return Math.sqrt(d)}}();class fn{constructor(n){this._getNewPrimitive=n,this._primitives=[]}getPrimitive(){const n=this._primitives;return n.length===0?this._getNewPrimitive():n.pop()}releasePrimitive(n){this._primitives.push(n)}}class ti extends fn{constructor(){super(()=>new ft)}}const X=new ti;class ni{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const n=[];let t=null;this.setBuffer=e=>{t&&n.push(t),t=e,this.float32Array=new Float32Array(e),this.uint16Array=new Uint16Array(e),this.uint32Array=new Uint32Array(e)},this.clearBuffer=()=>{t=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,n.length!==0&&this.setBuffer(n.pop())}}}const R=new ni;let Q,at;const it=[],Ut=new fn(()=>new j);function ii(i,n,t,e,s,c){Q=Ut.getPrimitive(),at=Ut.getPrimitive(),it.push(Q,at),R.setBuffer(i._roots[n]);const r=en(0,i.geometry,t,e,s,c);R.clearBuffer(),Ut.releasePrimitive(Q),Ut.releasePrimitive(at),it.pop(),it.pop();const l=it.length;return l>0&&(at=it[l-1],Q=it[l-2]),r}function en(i,n,t,e,s=null,c=0,r=0){const{float32Array:l,uint16Array:o,uint32Array:u}=R;let f=i*2;if(V(f,o)){const a=$(i,u),p=I(f,o);return D(i,l,Q),e(a,p,!1,r,c+i,Q)}else{let M=function(_){const{uint16Array:C,uint32Array:L}=R;let E=_*2;for(;!V(E,C);)_=k(_),E=_*2;return $(_,L)},U=function(_){const{uint16Array:C,uint32Array:L}=R;let E=_*2;for(;!V(E,C);)_=q(_,L),E=_*2;return $(_,L)+I(E,C)};const a=k(i),p=q(i,u);let d=a,b=p,g,h,x,m;if(s&&(x=Q,m=at,D(d,l,x),D(b,l,m),g=s(x),h=s(m),h<g)){d=p,b=a;const _=g;g=h,h=_,x=m}x||(x=Q,D(d,l,x));const w=V(d*2,o),A=t(x,w,g,r+1,c+d);let T;if(A===yn){const _=M(d),L=U(d)-_;T=e(_,L,!0,r+1,c+d,x)}else T=A&&en(d,n,t,e,s,c,r+1);if(T)return!0;m=at,D(b,l,m);const B=V(b*2,o),P=t(m,B,h,r+1,c+b);let S;if(P===yn){const _=M(b),L=U(b)-_;S=e(_,L,!0,r+1,c+b,m)}else S=P&&en(b,n,t,e,s,c,r+1);return!!S}}const mt=new z,Kt=new z;function ei(i,n,t={},e=0,s=1/0){const c=e*e,r=s*s;let l=1/0,o=null;if(i.shapecast({boundsTraverseOrder:f=>(mt.copy(n).clamp(f.min,f.max),mt.distanceToSquared(n)),intersectsBounds:(f,y,a)=>a<l&&a<r,intersectsTriangle:(f,y)=>{f.closestPointToPoint(n,mt);const a=n.distanceToSquared(mt);return a<l&&(Kt.copy(mt),l=a,o=y),a<c}}),l===1/0)return null;const u=Math.sqrt(l);return t.point?t.point.copy(Kt):t.point=Kt.clone(),t.distance=u,t.faceIndex=o,t}const si=parseInt(Rn)>=169,G=new z,O=new z,tt=new z,Lt=new Mt,Et=new Mt,zt=new Mt,gn=new z,wn=new z,Bn=new z,ht=new z;function ri(i,n,t,e,s,c,r,l){let o;if(c===Dn?o=i.intersectTriangle(e,t,n,!0,s):o=i.intersectTriangle(n,t,e,c!==Fn,s),o===null)return null;const u=i.origin.distanceTo(s);return u<r||u>l?null:{distance:u,point:s.clone()}}function oi(i,n,t,e,s,c,r,l,o,u,f){G.fromBufferAttribute(n,c),O.fromBufferAttribute(n,r),tt.fromBufferAttribute(n,l);const y=ri(i,G,O,tt,ht,o,u,f);if(y){const a=new z;xt.getBarycoord(ht,G,O,tt,a),e&&(Lt.fromBufferAttribute(e,c),Et.fromBufferAttribute(e,r),zt.fromBufferAttribute(e,l),y.uv=xt.getInterpolation(ht,G,O,tt,Lt,Et,zt,new Mt)),s&&(Lt.fromBufferAttribute(s,c),Et.fromBufferAttribute(s,r),zt.fromBufferAttribute(s,l),y.uv1=xt.getInterpolation(ht,G,O,tt,Lt,Et,zt,new Mt)),t&&(gn.fromBufferAttribute(t,c),wn.fromBufferAttribute(t,r),Bn.fromBufferAttribute(t,l),y.normal=xt.getInterpolation(ht,G,O,tt,gn,wn,Bn,new z),y.normal.dot(i.direction)>0&&y.normal.multiplyScalar(-1));const p={a:c,b:r,c:l,normal:new z,materialIndex:0};xt.getNormal(G,O,tt,p.normal),y.face=p,y.faceIndex=c,si&&(y.barycoord=a)}return y}function Xt(i,n,t,e,s,c,r){const l=e*3;let o=l+0,u=l+1,f=l+2;const y=i.index;i.index&&(o=y.getX(o),u=y.getX(u),f=y.getX(f));const{position:a,normal:p,uv:d,uv1:b}=i.attributes,g=oi(t,a,p,d,b,o,u,f,n,c,r);return g?(g.faceIndex=e,s&&s.push(g),g):null}function N(i,n,t,e){const s=i.a,c=i.b,r=i.c;let l=n,o=n+1,u=n+2;t&&(l=t.getX(l),o=t.getX(o),u=t.getX(u)),s.x=e.getX(l),s.y=e.getY(l),s.z=e.getZ(l),c.x=e.getX(o),c.y=e.getY(o),c.z=e.getZ(o),r.x=e.getX(u),r.y=e.getY(u),r.z=e.getZ(u)}function ci(i,n,t,e,s,c,r,l){const{geometry:o,_indirectBuffer:u}=i;for(let f=e,y=e+s;f<y;f++)Xt(o,n,t,f,c,r,l)}function li(i,n,t,e,s,c,r){const{geometry:l,_indirectBuffer:o}=i;let u=1/0,f=null;for(let y=e,a=e+s;y<a;y++){let p;p=Xt(l,n,t,y,null,c,r),p&&p.distance<u&&(f=p,u=p.distance)}return f}function ai(i,n,t,e,s,c,r){const{geometry:l}=t,{index:o}=l,u=l.attributes.position;for(let f=i,y=n+i;f<y;f++){let a;if(a=f,N(r,a*3,o,u),r.needsUpdate=!0,e(r,a,s,c))return!0}return!1}function fi(i,n=null){n&&Array.isArray(n)&&(n=new Set(n));const t=i.geometry,e=t.index?t.index.array:null,s=t.attributes.position;let c,r,l,o,u=0;const f=i._roots;for(let a=0,p=f.length;a<p;a++)c=f[a],r=new Uint32Array(c),l=new Uint16Array(c),o=new Float32Array(c),y(0,u),u+=c.byteLength;function y(a,p,d=!1){const b=a*2;if(l[b+15]===qt){const h=r[a+6],x=l[b+14];let m=1/0,w=1/0,A=1/0,T=-1/0,B=-1/0,P=-1/0;for(let S=3*h,M=3*(h+x);S<M;S++){let U=e[S];const _=s.getX(U),C=s.getY(U),L=s.getZ(U);_<m&&(m=_),_>T&&(T=_),C<w&&(w=C),C>B&&(B=C),L<A&&(A=L),L>P&&(P=L)}return o[a+0]!==m||o[a+1]!==w||o[a+2]!==A||o[a+3]!==T||o[a+4]!==B||o[a+5]!==P?(o[a+0]=m,o[a+1]=w,o[a+2]=A,o[a+3]=T,o[a+4]=B,o[a+5]=P,!0):!1}else{const h=a+8,x=r[a+6],m=h+p,w=x+p;let A=d,T=!1,B=!1;n?A||(T=n.has(m),B=n.has(w),A=!T&&!B):(T=!0,B=!0);const P=A||T,S=A||B;let M=!1;P&&(M=y(h,p,A));let U=!1;S&&(U=y(x,p,A));const _=M||U;if(_)for(let C=0;C<3;C++){const L=h+C,E=x+C,F=o[L],Z=o[L+3],pt=o[E],yt=o[E+3];o[a+C]=F<pt?F:pt,o[a+C+3]=Z>yt?Z:yt}return _}}}function W(i,n,t,e,s){let c,r,l,o,u,f;const y=1/t.direction.x,a=1/t.direction.y,p=1/t.direction.z,d=t.origin.x,b=t.origin.y,g=t.origin.z;let h=n[i],x=n[i+3],m=n[i+1],w=n[i+3+1],A=n[i+2],T=n[i+3+2];return y>=0?(c=(h-d)*y,r=(x-d)*y):(c=(x-d)*y,r=(h-d)*y),a>=0?(l=(m-b)*a,o=(w-b)*a):(l=(w-b)*a,o=(m-b)*a),c>o||l>r||((l>c||isNaN(c))&&(c=l),(o<r||isNaN(r))&&(r=o),p>=0?(u=(A-g)*p,f=(T-g)*p):(u=(T-g)*p,f=(A-g)*p),c>f||u>r)?!1:((u>c||c!==c)&&(c=u),(f<r||r!==r)&&(r=f),c<=s&&r>=e)}function ui(i,n,t,e,s,c,r,l){const{geometry:o,_indirectBuffer:u}=i;for(let f=e,y=e+s;f<y;f++){let a=u?u[f]:f;Xt(o,n,t,a,c,r,l)}}function pi(i,n,t,e,s,c,r){const{geometry:l,_indirectBuffer:o}=i;let u=1/0,f=null;for(let y=e,a=e+s;y<a;y++){let p;p=Xt(l,n,t,o?o[y]:y,null,c,r),p&&p.distance<u&&(f=p,u=p.distance)}return f}function yi(i,n,t,e,s,c,r){const{geometry:l}=t,{index:o}=l,u=l.attributes.position;for(let f=i,y=n+i;f<y;f++){let a;if(a=t.resolveTriangleIndex(f),N(r,a*3,o,u),r.needsUpdate=!0,e(r,a,s,c))return!0}return!1}function xi(i,n,t,e,s,c,r){R.setBuffer(i._roots[n]),sn(0,i,t,e,s,c,r),R.clearBuffer()}function sn(i,n,t,e,s,c,r){const{float32Array:l,uint16Array:o,uint32Array:u}=R,f=i*2;if(V(f,o)){const a=$(i,u),p=I(f,o);ci(n,t,e,a,p,s,c,r)}else{const a=k(i);W(a,l,e,c,r)&&sn(a,n,t,e,s,c,r);const p=q(i,u);W(p,l,e,c,r)&&sn(p,n,t,e,s,c,r)}}const Ai=["x","y","z"];function mi(i,n,t,e,s,c){R.setBuffer(i._roots[n]);const r=rn(0,i,t,e,s,c);return R.clearBuffer(),r}function rn(i,n,t,e,s,c){const{float32Array:r,uint16Array:l,uint32Array:o}=R;let u=i*2;if(V(u,l)){const y=$(i,o),a=I(u,l);return li(n,t,e,y,a,s,c)}else{const y=Cn(i,o),a=Ai[y],d=e.direction[a]>=0;let b,g;d?(b=k(i),g=q(i,o)):(b=q(i,o),g=k(i));const x=W(b,r,e,s,c)?rn(b,n,t,e,s,c):null;if(x){const A=x.point[a];if(d?A<=r[g+y]:A>=r[g+y+3])return x}const w=W(g,r,e,s,c)?rn(g,n,t,e,s,c):null;return x&&w?x.distance<=w.distance?x:w:x||w||null}}const Rt=new j,et=new ft,st=new ft,gt=new nt,dn=new v,Dt=new v;function hi(i,n,t,e){R.setBuffer(i._roots[n]);const s=on(0,i,t,e);return R.clearBuffer(),s}function on(i,n,t,e,s=null){const{float32Array:c,uint16Array:r,uint32Array:l}=R;let o=i*2;if(s===null&&(t.boundingBox||t.computeBoundingBox(),dn.set(t.boundingBox.min,t.boundingBox.max,e),s=dn),V(o,r)){const f=n.geometry,y=f.index,a=f.attributes.position,p=t.index,d=t.attributes.position,b=$(i,l),g=I(o,r);if(gt.copy(e).invert(),t.boundsTree)return D(i,c,Dt),Dt.matrix.copy(gt),Dt.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:x=>Dt.intersectsBox(x),intersectsTriangle:x=>{x.a.applyMatrix4(e),x.b.applyMatrix4(e),x.c.applyMatrix4(e),x.needsUpdate=!0;for(let m=b*3,w=(g+b)*3;m<w;m+=3)if(N(st,m,y,a),st.needsUpdate=!0,x.intersectsTriangle(st))return!0;return!1}});for(let h=b*3,x=(g+b)*3;h<x;h+=3){N(et,h,y,a),et.a.applyMatrix4(gt),et.b.applyMatrix4(gt),et.c.applyMatrix4(gt),et.needsUpdate=!0;for(let m=0,w=p.count;m<w;m+=3)if(N(st,m,p,d),st.needsUpdate=!0,et.intersectsTriangle(st))return!0}}else{const f=i+8,y=l[i+6];return D(f,c,Rt),!!(s.intersectsBox(Rt)&&on(f,n,t,e,s)||(D(y,c,Rt),s.intersectsBox(Rt)&&on(y,n,t,e,s)))}}const Ft=new nt,Jt=new v,wt=new v,gi=new z,wi=new z,Bi=new z,di=new z;function Ti(i,n,t,e={},s={},c=0,r=1/0){n.boundingBox||n.computeBoundingBox(),Jt.set(n.boundingBox.min,n.boundingBox.max,t),Jt.needsUpdate=!0;const l=i.geometry,o=l.attributes.position,u=l.index,f=n.attributes.position,y=n.index,a=X.getPrimitive(),p=X.getPrimitive();let d=gi,b=wi,g=null,h=null;s&&(g=Bi,h=di);let x=1/0,m=null,w=null;return Ft.copy(t).invert(),wt.matrix.copy(Ft),i.shapecast({boundsTraverseOrder:A=>Jt.distanceToBox(A),intersectsBounds:(A,T,B)=>B<x&&B<r?(T&&(wt.min.copy(A.min),wt.max.copy(A.max),wt.needsUpdate=!0),!0):!1,intersectsRange:(A,T)=>{if(n.boundsTree)return n.boundsTree.shapecast({boundsTraverseOrder:P=>wt.distanceToBox(P),intersectsBounds:(P,S,M)=>M<x&&M<r,intersectsRange:(P,S)=>{for(let M=P,U=P+S;M<U;M++){N(p,3*M,y,f),p.a.applyMatrix4(t),p.b.applyMatrix4(t),p.c.applyMatrix4(t),p.needsUpdate=!0;for(let _=A,C=A+T;_<C;_++){N(a,3*_,u,o),a.needsUpdate=!0;const L=a.distanceToTriangle(p,d,g);if(L<x&&(b.copy(d),h&&h.copy(g),x=L,m=_,w=M),L<c)return!0}}}});{const B=ut(n);for(let P=0,S=B;P<S;P++){N(p,3*P,y,f),p.a.applyMatrix4(t),p.b.applyMatrix4(t),p.c.applyMatrix4(t),p.needsUpdate=!0;for(let M=A,U=A+T;M<U;M++){N(a,3*M,u,o),a.needsUpdate=!0;const _=a.distanceToTriangle(p,d,g);if(_<x&&(b.copy(d),h&&h.copy(g),x=_,m=M,w=P),_<c)return!0}}}}}),X.releasePrimitive(a),X.releasePrimitive(p),x===1/0?null:(e.point?e.point.copy(b):e.point=b.clone(),e.distance=x,e.faceIndex=m,s&&(s.point?s.point.copy(h):s.point=h.clone(),s.point.applyMatrix4(Ft),b.applyMatrix4(Ft),s.distance=b.sub(s.point).length(),s.faceIndex=w),e)}function bi(i,n=null){n&&Array.isArray(n)&&(n=new Set(n));const t=i.geometry,e=t.index?t.index.array:null,s=t.attributes.position;let c,r,l,o,u=0;const f=i._roots;for(let a=0,p=f.length;a<p;a++)c=f[a],r=new Uint32Array(c),l=new Uint16Array(c),o=new Float32Array(c),y(0,u),u+=c.byteLength;function y(a,p,d=!1){const b=a*2;if(l[b+15]===qt){const h=r[a+6],x=l[b+14];let m=1/0,w=1/0,A=1/0,T=-1/0,B=-1/0,P=-1/0;for(let S=h,M=h+x;S<M;S++){const U=3*i.resolveTriangleIndex(S);for(let _=0;_<3;_++){let C=U+_;C=e?e[C]:C;const L=s.getX(C),E=s.getY(C),F=s.getZ(C);L<m&&(m=L),L>T&&(T=L),E<w&&(w=E),E>B&&(B=E),F<A&&(A=F),F>P&&(P=F)}}return o[a+0]!==m||o[a+1]!==w||o[a+2]!==A||o[a+3]!==T||o[a+4]!==B||o[a+5]!==P?(o[a+0]=m,o[a+1]=w,o[a+2]=A,o[a+3]=T,o[a+4]=B,o[a+5]=P,!0):!1}else{const h=a+8,x=r[a+6],m=h+p,w=x+p;let A=d,T=!1,B=!1;n?A||(T=n.has(m),B=n.has(w),A=!T&&!B):(T=!0,B=!0);const P=A||T,S=A||B;let M=!1;P&&(M=y(h,p,A));let U=!1;S&&(U=y(x,p,A));const _=M||U;if(_)for(let C=0;C<3;C++){const L=h+C,E=x+C,F=o[L],Z=o[L+3],pt=o[E],yt=o[E+3];o[a+C]=F<pt?F:pt,o[a+C+3]=Z>yt?Z:yt}return _}}}function _i(i,n,t,e,s,c,r){R.setBuffer(i._roots[n]),cn(0,i,t,e,s,c,r),R.clearBuffer()}function cn(i,n,t,e,s,c,r){const{float32Array:l,uint16Array:o,uint32Array:u}=R,f=i*2;if(V(f,o)){const a=$(i,u),p=I(f,o);ui(n,t,e,a,p,s,c,r)}else{const a=k(i);W(a,l,e,c,r)&&cn(a,n,t,e,s,c,r);const p=q(i,u);W(p,l,e,c,r)&&cn(p,n,t,e,s,c,r)}}const Pi=["x","y","z"];function Mi(i,n,t,e,s,c){R.setBuffer(i._roots[n]);const r=ln(0,i,t,e,s,c);return R.clearBuffer(),r}function ln(i,n,t,e,s,c){const{float32Array:r,uint16Array:l,uint32Array:o}=R;let u=i*2;if(V(u,l)){const y=$(i,o),a=I(u,l);return pi(n,t,e,y,a,s,c)}else{const y=Cn(i,o),a=Pi[y],d=e.direction[a]>=0;let b,g;d?(b=k(i),g=q(i,o)):(b=q(i,o),g=k(i));const x=W(b,r,e,s,c)?ln(b,n,t,e,s,c):null;if(x){const A=x.point[a];if(d?A<=r[g+y]:A>=r[g+y+3])return x}const w=W(g,r,e,s,c)?ln(g,n,t,e,s,c):null;return x&&w?x.distance<=w.distance?x:w:x||w||null}}const Nt=new j,rt=new ft,ot=new ft,Bt=new nt,Tn=new v,vt=new v;function Si(i,n,t,e){R.setBuffer(i._roots[n]);const s=an(0,i,t,e);return R.clearBuffer(),s}function an(i,n,t,e,s=null){const{float32Array:c,uint16Array:r,uint32Array:l}=R;let o=i*2;if(s===null&&(t.boundingBox||t.computeBoundingBox(),Tn.set(t.boundingBox.min,t.boundingBox.max,e),s=Tn),V(o,r)){const f=n.geometry,y=f.index,a=f.attributes.position,p=t.index,d=t.attributes.position,b=$(i,l),g=I(o,r);if(Bt.copy(e).invert(),t.boundsTree)return D(i,c,vt),vt.matrix.copy(Bt),vt.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:x=>vt.intersectsBox(x),intersectsTriangle:x=>{x.a.applyMatrix4(e),x.b.applyMatrix4(e),x.c.applyMatrix4(e),x.needsUpdate=!0;for(let m=b,w=g+b;m<w;m++)if(N(ot,3*n.resolveTriangleIndex(m),y,a),ot.needsUpdate=!0,x.intersectsTriangle(ot))return!0;return!1}});for(let h=b,x=g+b;h<x;h++){const m=n.resolveTriangleIndex(h);N(rt,3*m,y,a),rt.a.applyMatrix4(Bt),rt.b.applyMatrix4(Bt),rt.c.applyMatrix4(Bt),rt.needsUpdate=!0;for(let w=0,A=p.count;w<A;w+=3)if(N(ot,w,p,d),ot.needsUpdate=!0,rt.intersectsTriangle(ot))return!0}}else{const f=i+8,y=l[i+6];return D(f,c,Nt),!!(s.intersectsBox(Nt)&&an(f,n,t,e,s)||(D(y,c,Nt),s.intersectsBox(Nt)&&an(y,n,t,e,s)))}}const Vt=new nt,Qt=new v,dt=new v,Ci=new z,Ui=new z,Li=new z,Ei=new z;function zi(i,n,t,e={},s={},c=0,r=1/0){n.boundingBox||n.computeBoundingBox(),Qt.set(n.boundingBox.min,n.boundingBox.max,t),Qt.needsUpdate=!0;const l=i.geometry,o=l.attributes.position,u=l.index,f=n.attributes.position,y=n.index,a=X.getPrimitive(),p=X.getPrimitive();let d=Ci,b=Ui,g=null,h=null;s&&(g=Li,h=Ei);let x=1/0,m=null,w=null;return Vt.copy(t).invert(),dt.matrix.copy(Vt),i.shapecast({boundsTraverseOrder:A=>Qt.distanceToBox(A),intersectsBounds:(A,T,B)=>B<x&&B<r?(T&&(dt.min.copy(A.min),dt.max.copy(A.max),dt.needsUpdate=!0),!0):!1,intersectsRange:(A,T)=>{if(n.boundsTree){const B=n.boundsTree;return B.shapecast({boundsTraverseOrder:P=>dt.distanceToBox(P),intersectsBounds:(P,S,M)=>M<x&&M<r,intersectsRange:(P,S)=>{for(let M=P,U=P+S;M<U;M++){const _=B.resolveTriangleIndex(M);N(p,3*_,y,f),p.a.applyMatrix4(t),p.b.applyMatrix4(t),p.c.applyMatrix4(t),p.needsUpdate=!0;for(let C=A,L=A+T;C<L;C++){const E=i.resolveTriangleIndex(C);N(a,3*E,u,o),a.needsUpdate=!0;const F=a.distanceToTriangle(p,d,g);if(F<x&&(b.copy(d),h&&h.copy(g),x=F,m=C,w=M),F<c)return!0}}}})}else{const B=ut(n);for(let P=0,S=B;P<S;P++){N(p,3*P,y,f),p.a.applyMatrix4(t),p.b.applyMatrix4(t),p.c.applyMatrix4(t),p.needsUpdate=!0;for(let M=A,U=A+T;M<U;M++){const _=i.resolveTriangleIndex(M);N(a,3*_,u,o),a.needsUpdate=!0;const C=a.distanceToTriangle(p,d,g);if(C<x&&(b.copy(d),h&&h.copy(g),x=C,m=M,w=P),C<c)return!0}}}}}),X.releasePrimitive(a),X.releasePrimitive(p),x===1/0?null:(e.point?e.point.copy(b):e.point=b.clone(),e.distance=x,e.faceIndex=m,s&&(s.point?s.point.copy(h):s.point=h.clone(),s.point.applyMatrix4(Vt),b.applyMatrix4(Vt),s.distance=b.sub(s.point).length(),s.faceIndex=w),e)}function Ri(){return typeof SharedArrayBuffer<"u"}function Ii(i,n){if(i===null)return i;if(i.buffer){const t=i.buffer;if(t.constructor===n)return i;const e=i.constructor,s=new e(new n(t.byteLength));return s.set(i),s}else{if(i.constructor===n)return i;const t=new n(i.byteLength);return new Uint8Array(t).set(new Uint8Array(i)),t}}const _t=new R.constructor,kt=new R.constructor,J=new fn(()=>new j),ct=new j,lt=new j,Wt=new j,Gt=new j;let Ot=!1;function Di(i,n,t,e){if(Ot)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Ot=!0;const s=i._roots,c=n._roots;let r,l=0,o=0;const u=new nt().copy(t).invert();for(let f=0,y=s.length;f<y;f++){_t.setBuffer(s[f]),o=0;const a=J.getPrimitive();D(0,_t.float32Array,a),a.applyMatrix4(u);for(let p=0,d=c.length;p<d&&(kt.setBuffer(c[p]),r=H(0,0,t,u,e,l,o,0,0,a),kt.clearBuffer(),o+=c[p].length,!r);p++);if(J.releasePrimitive(a),_t.clearBuffer(),l+=s[f].length,r)break}return Ot=!1,r}function H(i,n,t,e,s,c=0,r=0,l=0,o=0,u=null,f=!1){let y,a;f?(y=kt,a=_t):(y=_t,a=kt);const p=y.float32Array,d=y.uint32Array,b=y.uint16Array,g=a.float32Array,h=a.uint32Array,x=a.uint16Array,m=i*2,w=n*2,A=V(m,b),T=V(w,x);let B=!1;if(T&&A)f?B=s($(n,h),I(n*2,x),$(i,d),I(i*2,b),o,r+n,l,c+i):B=s($(i,d),I(i*2,b),$(n,h),I(n*2,x),l,c+i,o,r+n);else if(T){const P=J.getPrimitive();D(n,g,P),P.applyMatrix4(t);const S=k(i),M=q(i,d);D(S,p,ct),D(M,p,lt);const U=P.intersectsBox(ct),_=P.intersectsBox(lt);B=U&&H(n,S,e,t,s,r,c,o,l+1,P,!f)||_&&H(n,M,e,t,s,r,c,o,l+1,P,!f),J.releasePrimitive(P)}else{const P=k(n),S=q(n,h);D(P,g,Wt),D(S,g,Gt);const M=u.intersectsBox(Wt),U=u.intersectsBox(Gt);if(M&&U)B=H(i,P,t,e,s,c,r,l,o+1,u,f)||H(i,S,t,e,s,c,r,l,o+1,u,f);else if(M)if(A)B=H(i,P,t,e,s,c,r,l,o+1,u,f);else{const _=J.getPrimitive();_.copy(Wt).applyMatrix4(t);const C=k(i),L=q(i,d);D(C,p,ct),D(L,p,lt);const E=_.intersectsBox(ct),F=_.intersectsBox(lt);B=E&&H(P,C,e,t,s,r,c,o,l+1,_,!f)||F&&H(P,L,e,t,s,r,c,o,l+1,_,!f),J.releasePrimitive(_)}else if(U)if(A)B=H(i,S,t,e,s,c,r,l,o+1,u,f);else{const _=J.getPrimitive();_.copy(Gt).applyMatrix4(t);const C=k(i),L=q(i,d);D(C,p,ct),D(L,p,lt);const E=_.intersectsBox(ct),F=_.intersectsBox(lt);B=E&&H(S,C,e,t,s,r,c,o,l+1,_,!f)||F&&H(S,L,e,t,s,r,c,o,l+1,_,!f),J.releasePrimitive(_)}}return B}const $t=new v,bn=new j,Fi={strategy:Pn,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null};class En{static serialize(n,t={}){t={cloneBuffers:!0,...t};const e=n.geometry,s=n._roots,c=n._indirectBuffer,r=e.getIndex();let l;return t.cloneBuffers?l={roots:s.map(o=>o.slice()),index:r?r.array.slice():null,indirectBuffer:c?c.slice():null}:l={roots:s,index:r?r.array:null,indirectBuffer:c},l}static deserialize(n,t,e={}){e={setIndex:!0,indirect:!!n.indirectBuffer,...e};const{index:s,roots:c,indirectBuffer:r}=n,l=new En(t,{...e,[jt]:!0});if(l._roots=c,l._indirectBuffer=r||null,e.setIndex){const o=t.getIndex();if(o===null){const u=new _n(n.index,1,!1);t.setIndex(u)}else o.array!==s&&(o.array.set(s),o.needsUpdate=!0)}return l}get indirect(){return!!this._indirectBuffer}constructor(n,t={}){if(n.isBufferGeometry){if(n.index&&n.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign({...Fi,[jt]:!1},t),t.useSharedArrayBuffer&&!Ri())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=n,this._roots=null,this._indirectBuffer=null,t[jt]||(On(this,t),!n.boundingBox&&t.setBoundingBox&&(n.boundingBox=this.getBoundingBox(new j))),this.resolveTriangleIndex=t.indirect?e=>this._indirectBuffer[e]:e=>e}refit(n=null){return(this.indirect?bi:fi)(this,n)}traverse(n,t=0){const e=this._roots[t],s=new Uint32Array(e),c=new Uint16Array(e);r(0);function r(l,o=0){const u=l*2,f=c[u+15]===qt;if(f){const y=s[l+6],a=c[u+14];n(o,f,new Float32Array(e,l*4,6),y,a)}else{const y=l+bt/4,a=s[l+6],p=s[l+7];n(o,f,new Float32Array(e,l*4,6),p)||(r(y,o+1),r(a,o+1))}}}raycast(n,t=pn,e=0,s=1/0){const c=this._roots,r=this.geometry,l=[],o=t.isMaterial,u=Array.isArray(t),f=r.groups,y=o?t.side:t,a=this.indirect?_i:xi;for(let p=0,d=c.length;p<d;p++){const b=u?t[f[p].materialIndex].side:y,g=l.length;if(a(this,p,b,n,l,e,s),u){const h=f[p].materialIndex;for(let x=g,m=l.length;x<m;x++)l[x].face.materialIndex=h}}return l}raycastFirst(n,t=pn,e=0,s=1/0){const c=this._roots,r=this.geometry,l=t.isMaterial,o=Array.isArray(t);let u=null;const f=r.groups,y=l?t.side:t,a=this.indirect?Mi:mi;for(let p=0,d=c.length;p<d;p++){const b=o?t[f[p].materialIndex].side:y,g=a(this,p,b,n,e,s);g!=null&&(u==null||g.distance<u.distance)&&(u=g,o&&(g.face.materialIndex=f[p].materialIndex))}return u}intersectsGeometry(n,t){let e=!1;const s=this._roots,c=this.indirect?Si:hi;for(let r=0,l=s.length;r<l&&(e=c(this,r,n,t),!e);r++);return e}shapecast(n){const t=X.getPrimitive(),e=this.indirect?yi:ai;let{boundsTraverseOrder:s,intersectsBounds:c,intersectsRange:r,intersectsTriangle:l}=n;if(r&&l){const y=r;r=(a,p,d,b,g)=>y(a,p,d,b,g)?!0:e(a,p,this,l,d,b,t)}else r||(l?r=(y,a,p,d)=>e(y,a,this,l,p,d,t):r=(y,a,p)=>p);let o=!1,u=0;const f=this._roots;for(let y=0,a=f.length;y<a;y++){const p=f[y];if(o=ii(this,y,c,r,s,u),o)break;u+=p.byteLength}return X.releasePrimitive(t),o}bvhcast(n,t,e){let{intersectsRanges:s,intersectsTriangles:c}=e;const r=X.getPrimitive(),l=this.geometry.index,o=this.geometry.attributes.position,u=this.indirect?d=>{const b=this.resolveTriangleIndex(d);N(r,b*3,l,o)}:d=>{N(r,d*3,l,o)},f=X.getPrimitive(),y=n.geometry.index,a=n.geometry.attributes.position,p=n.indirect?d=>{const b=n.resolveTriangleIndex(d);N(f,b*3,y,a)}:d=>{N(f,d*3,y,a)};if(c){const d=(b,g,h,x,m,w,A,T)=>{for(let B=h,P=h+x;B<P;B++){p(B),f.a.applyMatrix4(t),f.b.applyMatrix4(t),f.c.applyMatrix4(t),f.needsUpdate=!0;for(let S=b,M=b+g;S<M;S++)if(u(S),r.needsUpdate=!0,c(r,f,S,B,m,w,A,T))return!0}return!1};if(s){const b=s;s=function(g,h,x,m,w,A,T,B){return b(g,h,x,m,w,A,T,B)?!0:d(g,h,x,m,w,A,T,B)}}else s=d}return Di(this,n,t,s)}intersectsBox(n,t){return $t.set(n.min,n.max,t),$t.needsUpdate=!0,this.shapecast({intersectsBounds:e=>$t.intersectsBox(e),intersectsTriangle:e=>$t.intersectsTriangle(e)})}intersectsSphere(n){return this.shapecast({intersectsBounds:t=>n.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(n)})}closestPointToGeometry(n,t,e={},s={},c=0,r=1/0){return(this.indirect?zi:Ti)(this,n,t,e,s,c,r)}closestPointToPoint(n,t={},e=0,s=1/0){return ei(this,n,t,e,s)}getBoundingBox(n){return n.makeEmpty(),this._roots.forEach(e=>{D(0,new Float32Array(e),bn),n.union(bn)}),n}}export{Nn as A,bt as B,Pn as C,Vi as I,En as M,vi as N,$ as O,q as R,vn as S,Ht as T,yn as a,$n as b,Ii as c,V as d,kn as e,I as f,In as g,Cn as h,Ri as i,$i as j,xn as k,D as l};
